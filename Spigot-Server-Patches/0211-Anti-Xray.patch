From b82dea6633d58d47574612205e7181b4147ef162 Mon Sep 17 00:00:00 2001
From: stonar96 <minecraft.stonar96@gmail.com>
Date: Thu, 21 Sep 2017 00:38:47 +0200
Subject: [PATCH] Anti-Xray


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index c80d84b9b..6344537ec 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -1,7 +1,10 @@
 package com.destroystokyo.paper;
 
+import java.util.Arrays;
 import java.util.List;
 
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray.ChunkEdgeMode;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray.EngineMode;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
@@ -361,4 +364,27 @@ public class PaperWorldConfig {
         disableCreeperLingeringEffect = getBoolean("disable-creeper-lingering-effect", false);
         log("Creeper lingering effect: " + disableCreeperLingeringEffect);
     }
+
+    public boolean antiXray;
+    public boolean asynchronous;
+    public EngineMode engineMode;
+    public ChunkEdgeMode chunkEdgeMode;
+    public int maxChunkSectionIndex;
+    public int updateRadius;
+    public List<Object> hiddenBlocks;
+    public List<Object> replacementBlocks;
+    private void antiXray() {
+        antiXray = getBoolean("anti-xray.enabled", false);
+        asynchronous = true;
+        engineMode = EngineMode.getById(getInt("anti-xray.engine-mode", EngineMode.HIDE.getId()));
+        engineMode = engineMode == null ? EngineMode.HIDE : engineMode;
+        chunkEdgeMode = ChunkEdgeMode.getById(getInt("anti-xray.chunk-edge-mode", ChunkEdgeMode.DEFAULT.getId()));
+        chunkEdgeMode = chunkEdgeMode == null ? ChunkEdgeMode.DEFAULT : chunkEdgeMode;
+        maxChunkSectionIndex = getInt("anti-xray.max-chunk-section-index", 3);
+        maxChunkSectionIndex = maxChunkSectionIndex > 15 ? 15 : maxChunkSectionIndex;
+        updateRadius = getInt("anti-xray.update-radius", 2);
+        hiddenBlocks = getList("anti-xray.hidden-blocks", Arrays.asList((Object) "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone", "obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore", "ender_chest"));
+        replacementBlocks = getList("anti-xray.replacement-blocks", Arrays.asList((Object) "stone", "planks"));
+        log("Anti-Xray: " + (antiXray ? "enabled" : "disabled") + " / Engine Mode: " + engineMode.getDescription() + " / Chunk Edge Mode: " + chunkEdgeMode.getDescription() + " / Up to " + ((maxChunkSectionIndex + 1) * 16) + " blocks / Update Radius: " + updateRadius);
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
new file mode 100644
index 000000000..6833cfad2
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
@@ -0,0 +1,36 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.World;
+
+public class ChunkPacketBlockController {
+
+    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+
+    protected ChunkPacketBlockController() {
+        
+    }
+
+    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkSectionIndex) {
+        return null;
+    }
+
+    public boolean onChunkPacketCreate(Chunk chunk, int chunkSectionSelector, boolean force) {
+        return true;
+    }
+
+    public PacketPlayOutMapChunkInfo getPacketPlayOutMapChunkInfo(PacketPlayOutMapChunk packetPlayOutMapChunk, Chunk chunk, int chunkSectionSelector) {
+        return null;
+    }
+
+    public void modifyBlocks(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketPlayOutMapChunkInfo packetPlayOutMapChunkInfo) {
+        packetPlayOutMapChunk.setReady(true);
+    }
+
+    public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
+
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
new file mode 100644
index 000000000..2dc0655a9
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -0,0 +1,640 @@
+package com.destroystokyo.paper.antixray;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ExecutorService;
+
+import com.destroystokyo.paper.PaperWorldConfig;
+
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.DataPalette;
+import net.minecraft.server.DataPaletteBlock;
+import net.minecraft.server.DataPaletteGlobal;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMapChunk;
+import net.minecraft.server.World;
+
+import org.bukkit.World.Environment;
+
+public class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+
+    private static ExecutorService executorServiceInstance = null;
+    private final ExecutorService executorService;
+    private final boolean asynchronous;
+    private final EngineMode engineMode;
+    private final ChunkEdgeMode chunkEdgeMode;
+    private final int maxChunkSectionIndex;
+    private final int updateRadius;
+    private final IBlockData[] predefinedBlockData;
+    private final IBlockData[] predefinedBlockDataStone;
+    private final IBlockData[] predefinedBlockDataNetherrack;
+    private final IBlockData[] predefinedBlockDataEndStone;
+    private final int[] predefinedBlockDataBits;
+    private final int[] predefinedBlockDataBitsGlobal;
+    private final int[] predefinedBlockDataBitsStoneGlobal;
+    private final int[] predefinedBlockDataBitsNetherrackGlobal;
+    private final int[] predefinedBlockDataBitsEndStoneGlobal;
+    private final boolean[] solidGlobal = new boolean[Block.REGISTRY_ID.size()];
+    private final boolean[] obfuscateGlobal = new boolean[Block.REGISTRY_ID.size()];
+    private final ChunkSection[] emptyNearbyChunkSections = {Chunk.EMPTY_CHUNK_SECTION, Chunk.EMPTY_CHUNK_SECTION, Chunk.EMPTY_CHUNK_SECTION, Chunk.EMPTY_CHUNK_SECTION};
+
+    public ChunkPacketBlockControllerAntiXray(PaperWorldConfig paperWorldConfig) {
+        asynchronous = paperWorldConfig.asynchronous;
+        engineMode = paperWorldConfig.engineMode;
+        chunkEdgeMode = paperWorldConfig.chunkEdgeMode;
+        maxChunkSectionIndex = paperWorldConfig.maxChunkSectionIndex;
+        updateRadius = paperWorldConfig.updateRadius;
+
+        if (asynchronous) {
+            executorService = getExecutorServiceInstance();
+        } else {
+            executorService = null;
+        }
+
+        if (engineMode == EngineMode.HIDE) {
+            predefinedBlockData = null;
+            predefinedBlockDataStone = new IBlockData[] {Blocks.STONE.getBlockData()};
+            predefinedBlockDataNetherrack = new IBlockData[] {Blocks.NETHERRACK.getBlockData()};
+            predefinedBlockDataEndStone = new IBlockData[] {Blocks.END_STONE.getBlockData()};
+            predefinedBlockDataBits = new int[] {1};
+            predefinedBlockDataBitsGlobal = null;
+            predefinedBlockDataBitsStoneGlobal = new int[] {Block.REGISTRY_ID.getId(Blocks.STONE.getBlockData())};
+            predefinedBlockDataBitsNetherrackGlobal = new int[] {Block.REGISTRY_ID.getId(Blocks.NETHERRACK.getBlockData())};
+            predefinedBlockDataBitsEndStoneGlobal = new int[] {Block.REGISTRY_ID.getId(Blocks.END_STONE.getBlockData())};
+        } else {
+            Set<IBlockData> predefinedBlockDataSet = new HashSet<IBlockData>();
+
+            for (Object id : paperWorldConfig.hiddenBlocks) {
+                Block block = Block.getByName(String.valueOf(id));
+
+                if (block != null && !block.isTileEntity()) {
+                    predefinedBlockDataSet.add(block.getBlockData());
+                }
+            }
+
+            predefinedBlockData = predefinedBlockDataSet.size() == 0 ? new IBlockData[] {Blocks.DIAMOND_ORE.getBlockData()} : predefinedBlockDataSet.toArray(new IBlockData[predefinedBlockDataSet.size()]);
+            predefinedBlockDataStone = null;
+            predefinedBlockDataNetherrack = null;
+            predefinedBlockDataEndStone = null;
+            predefinedBlockDataBits = new int[predefinedBlockData.length];
+            predefinedBlockDataBitsGlobal = new int[predefinedBlockData.length];
+            boolean containsDefaultBlockData = false;
+
+            for (int i = 0; i < predefinedBlockData.length; i++) {
+                predefinedBlockDataBits[i] = containsDefaultBlockData ? i : (containsDefaultBlockData = predefinedBlockData[i] == DataPaletteBlock.DEFAULT_BLOCK_DATA) ? 0 : i + 1;
+                predefinedBlockDataBitsGlobal[i] = Block.REGISTRY_ID.getId(predefinedBlockData[i]);
+            }
+
+            predefinedBlockDataBitsStoneGlobal = null;
+            predefinedBlockDataBitsNetherrackGlobal = null;
+            predefinedBlockDataBitsEndStoneGlobal = null;
+        }
+
+        for (Object id : (engineMode == EngineMode.HIDE) ? paperWorldConfig.hiddenBlocks : paperWorldConfig.replacementBlocks) {
+            Block block = Block.getByName(String.valueOf(id));
+
+            if (block != null) {
+                obfuscateGlobal[Block.REGISTRY_ID.getId(block.getBlockData())] = true;
+            }
+        }
+
+        for (int i = 0; i < solidGlobal.length; i++) {
+            IBlockData blockData = Block.REGISTRY_ID.fromId(i);
+
+            if (blockData != null) {
+                solidGlobal[i] = blockData.getBlock().isOccluding(blockData) && blockData.getBlock() != Blocks.MOB_SPAWNER && blockData.getBlock() != Blocks.BARRIER;
+            }
+        }
+    }
+
+    private static ExecutorService getExecutorServiceInstance() {
+        if (executorServiceInstance == null) {
+            executorServiceInstance = Executors.newSingleThreadExecutor();
+        }
+
+        return executorServiceInstance;
+    }
+
+    @Override
+    public IBlockData[] getPredefinedBlockData(Chunk chunk, int chunkSectionIndex) {
+        //Return the block data which should be added to the data palettes so that they can be used for the obfuscation
+        if (chunkSectionIndex <= maxChunkSectionIndex) {
+            switch (engineMode) {
+                case HIDE:
+                    switch (chunk.world.getWorld().getEnvironment()) {
+                        case NETHER:
+                            return predefinedBlockDataNetherrack;
+                        case THE_END:
+                            return predefinedBlockDataEndStone;
+                        default:
+                            return predefinedBlockDataStone;
+                    }
+                default:
+                    return predefinedBlockData;
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean onChunkPacketCreate(Chunk chunk, int chunkSectionSelector, boolean force) {
+        //Load nearby chunks if necessary
+        if (chunkEdgeMode == ChunkEdgeMode.WAIT && !force) {
+            if (chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ) == null || chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ) == null || chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1) == null || chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1) == null) {
+                //Don't create the chunk packet now, wait until nearby chunks are loaded and create it later
+                return false;
+            }
+        } else if (chunkEdgeMode == ChunkEdgeMode.LOAD || chunkEdgeMode == ChunkEdgeMode.WAIT) {
+            chunk.world.getChunkAt(chunk.locX - 1, chunk.locZ);
+            chunk.world.getChunkAt(chunk.locX + 1, chunk.locZ);
+            chunk.world.getChunkAt(chunk.locX, chunk.locZ - 1);
+            chunk.world.getChunkAt(chunk.locX, chunk.locZ + 1);
+        }
+
+        //Create the chunk packet now
+        return true;
+    }
+
+    @Override
+    public PacketPlayOutMapChunkInfoAntiXray getPacketPlayOutMapChunkInfo(PacketPlayOutMapChunk packetPlayOutMapChunk, Chunk chunk, int chunkSectionSelector) {
+        //Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        PacketPlayOutMapChunkInfoAntiXray packetPlayOutMapChunkInfoAntiXray = new PacketPlayOutMapChunkInfoAntiXray(packetPlayOutMapChunk, chunk, chunkSectionSelector, this);
+        packetPlayOutMapChunkInfoAntiXray.setNearbyChunks(chunk.world.getChunkIfLoaded(chunk.locX - 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX + 1, chunk.locZ), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ - 1), chunk.world.getChunkIfLoaded(chunk.locX, chunk.locZ + 1));
+        return packetPlayOutMapChunkInfoAntiXray;
+    }
+
+    @Override
+    public void modifyBlocks(PacketPlayOutMapChunk packetPlayOutMapChunk, PacketPlayOutMapChunkInfo packetPlayOutMapChunkInfo) {
+        if (asynchronous) {
+            executorService.submit((PacketPlayOutMapChunkInfoAntiXray) packetPlayOutMapChunkInfo);
+        } else {
+            obfuscate((PacketPlayOutMapChunkInfoAntiXray) packetPlayOutMapChunkInfo);
+        }
+    }
+
+    //Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay
+    private final boolean[] solid = new boolean[Block.REGISTRY_ID.size()];
+    private final boolean[] obfuscate = new boolean[Block.REGISTRY_ID.size()];
+    //These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
+    private boolean[][] current = new boolean[16][16];
+    private boolean[][] next = new boolean[16][16];
+    private boolean[][] nextNext = new boolean[16][16];
+    private final DataBitsReader dataBitsReader = new DataBitsReader();
+    private final DataBitsWriter dataBitsWriter = new DataBitsWriter();
+    private final ChunkSection[] nearbyChunkSections = new ChunkSection[4];
+
+    public void obfuscate(PacketPlayOutMapChunkInfoAntiXray packetPlayOutMapChunkInfoAntiXray) {
+        boolean[] solidTemp = null;
+        boolean[] obfuscateTemp = null;
+        dataBitsReader.setDataBits(packetPlayOutMapChunkInfoAntiXray.getData());
+        dataBitsWriter.setDataBits(packetPlayOutMapChunkInfoAntiXray.getData());
+        int counter = 0;
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex <= maxChunkSectionIndex; chunkSectionIndex++) {
+            if (packetPlayOutMapChunkInfoAntiXray.isWritten(chunkSectionIndex) && packetPlayOutMapChunkInfoAntiXray.getPredefinedBlockData(chunkSectionIndex) != null) {
+                int[] predefinedBlockDataBitsTemp = packetPlayOutMapChunkInfoAntiXray.getDataPalette(chunkSectionIndex) instanceof DataPaletteGlobal ? engineMode == EngineMode.HIDE ? packetPlayOutMapChunkInfoAntiXray.getChunk().world.getWorld().getEnvironment() == Environment.NETHER ? predefinedBlockDataBitsNetherrackGlobal : packetPlayOutMapChunkInfoAntiXray.getChunk().world.getWorld().getEnvironment() == Environment.THE_END ? predefinedBlockDataBitsEndStoneGlobal : predefinedBlockDataBitsStoneGlobal : predefinedBlockDataBitsGlobal : predefinedBlockDataBits;
+                dataBitsWriter.setIndex(packetPlayOutMapChunkInfoAntiXray.getDataBitsIndex(chunkSectionIndex));
+
+                //Check if the chunk section below was not obfuscated
+                if (chunkSectionIndex == 0 || !packetPlayOutMapChunkInfoAntiXray.isWritten(chunkSectionIndex - 1) || packetPlayOutMapChunkInfoAntiXray.getPredefinedBlockData(chunkSectionIndex - 1) == null) {
+                    //If so, initialize some stuff
+                    dataBitsReader.setBitsPerValue(packetPlayOutMapChunkInfoAntiXray.getBitsPerValue(chunkSectionIndex));
+                    dataBitsReader.setIndex(packetPlayOutMapChunkInfoAntiXray.getDataBitsIndex(chunkSectionIndex));
+                    solidTemp = readDataPalette(packetPlayOutMapChunkInfoAntiXray.getDataPalette(chunkSectionIndex), solid, solidGlobal);
+                    obfuscateTemp = readDataPalette(packetPlayOutMapChunkInfoAntiXray.getDataPalette(chunkSectionIndex), obfuscate, obfuscateGlobal);
+                    //Read the blocks of the upper layer of the chunk section below if it exists
+                    ChunkSection belowChunkSection = null;
+                    boolean skipFirstLayer = chunkSectionIndex == 0 || (belowChunkSection = packetPlayOutMapChunkInfoAntiXray.getChunk().getSections()[chunkSectionIndex - 1]) == Chunk.EMPTY_CHUNK_SECTION;
+
+                    for (int z = 0; z < 16; z++) {
+                        for (int x = 0; x < 16; x++) {
+                            current[z][x] = true;
+                            next[z][x] = skipFirstLayer || !solidGlobal[Block.REGISTRY_ID.getId(belowChunkSection.getType(x, 15, z))];
+                        }
+                    }
+
+                    //Abuse the obfuscateLayer method to read the blocks of the first layer of the current chunk section
+                    dataBitsWriter.setBitsPerValue(0);
+                    obfuscateLayer(-1, dataBitsReader, dataBitsWriter, solidTemp, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, emptyNearbyChunkSections, counter);
+                }
+
+                dataBitsWriter.setBitsPerValue(packetPlayOutMapChunkInfoAntiXray.getBitsPerValue(chunkSectionIndex));
+                nearbyChunkSections[0] = packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[0] == null ? Chunk.EMPTY_CHUNK_SECTION : packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[0].getSections()[chunkSectionIndex];
+                nearbyChunkSections[1] = packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[1] == null ? Chunk.EMPTY_CHUNK_SECTION : packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[1].getSections()[chunkSectionIndex];
+                nearbyChunkSections[2] = packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[2] == null ? Chunk.EMPTY_CHUNK_SECTION : packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[2].getSections()[chunkSectionIndex];
+                nearbyChunkSections[3] = packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[3] == null ? Chunk.EMPTY_CHUNK_SECTION : packetPlayOutMapChunkInfoAntiXray.getNearbyChunks()[3].getSections()[chunkSectionIndex];
+
+                //Obfuscate all layers of the current chunk section except the upper one
+                for (int y = 0; y < 15; y++) {
+                    boolean[][] temp = current;
+                    current = next;
+                    next = nextNext;
+                    nextNext = temp;
+                    counter = obfuscateLayer(y, dataBitsReader, dataBitsWriter, solidTemp, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, nearbyChunkSections, counter);
+                }
+
+                //Check if the chunk section above doesn't need obfuscation
+                if (chunkSectionIndex == maxChunkSectionIndex || !packetPlayOutMapChunkInfoAntiXray.isWritten(chunkSectionIndex + 1) || packetPlayOutMapChunkInfoAntiXray.getPredefinedBlockData(chunkSectionIndex + 1) == null) {
+                    //If so, obfuscate the upper layer of the current chunk section by reading blocks of the first layer from the chunk section above if it exists
+                    ChunkSection aboveChunkSection;
+
+                    if (chunkSectionIndex != 15 && (aboveChunkSection = packetPlayOutMapChunkInfoAntiXray.getChunk().getSections()[chunkSectionIndex + 1]) != Chunk.EMPTY_CHUNK_SECTION) {
+                        boolean[][] temp = current;
+                        current = next;
+                        next = nextNext;
+                        nextNext = temp;
+
+                        for (int z = 0; z < 16; z++) {
+                            for (int x = 0; x < 16; x++) {
+                                if (!solidGlobal[Block.REGISTRY_ID.getId(aboveChunkSection.getType(x, 0, z))]) {
+                                    current[z][x] = true;
+                                }
+                            }
+                        }
+
+                        //There is nothing to read anymore
+                        dataBitsReader.setBitsPerValue(0);
+                        solid[0] = true;
+                        counter = obfuscateLayer(15, dataBitsReader, dataBitsWriter, solid, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, nearbyChunkSections, counter);
+                    }
+                } else {
+                    //If not, initialize the reader and other stuff for the chunk section above to obfuscate the upper layer of the current chunk section
+                    dataBitsReader.setBitsPerValue(packetPlayOutMapChunkInfoAntiXray.getBitsPerValue(chunkSectionIndex + 1));
+                    dataBitsReader.setIndex(packetPlayOutMapChunkInfoAntiXray.getDataBitsIndex(chunkSectionIndex + 1));
+                    solidTemp = readDataPalette(packetPlayOutMapChunkInfoAntiXray.getDataPalette(chunkSectionIndex + 1), solid, solidGlobal);
+                    obfuscateTemp = readDataPalette(packetPlayOutMapChunkInfoAntiXray.getDataPalette(chunkSectionIndex + 1), obfuscate, obfuscateGlobal);
+                    boolean[][] temp = current;
+                    current = next;
+                    next = nextNext;
+                    nextNext = temp;
+                    counter = obfuscateLayer(15, dataBitsReader, dataBitsWriter, solidTemp, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, nearbyChunkSections, counter);
+                }
+
+                dataBitsWriter.finish();
+            }
+        }
+
+        packetPlayOutMapChunkInfoAntiXray.getPacketPlayOutMapChunk().setReady(true);
+    }
+
+    private int obfuscateLayer(int y, DataBitsReader dataBitsReader, DataBitsWriter dataBitsWriter, boolean[] solid, boolean[] obfuscate, int[] predefinedBlockDataBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, ChunkSection[] nearbyChunkSections, int counter) {
+        //First block of first line
+        int dataBits = dataBitsReader.read();
+
+        if (nextNext[0][0] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[0][1] = true;
+            next[1][0] = true;
+        } else {
+            if (nearbyChunkSections[2] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[2].getType(0, y, 15))] || nearbyChunkSections[0] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[0].getType(15, y, 0))] || current[0][0]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[0][0] = true;
+        }
+
+        //First line
+        for (int x = 1; x < 15; x++) {
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[0][x] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[0][x - 1] = true;
+                next[0][x + 1] = true;
+                next[1][x] = true;
+            } else {
+                if (nearbyChunkSections[2] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[2].getType(x, y, 15))] || current[0][x]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[0][x] = true;
+            }
+        }
+
+        //Last block of first line
+        dataBits = dataBitsReader.read();
+
+        if (nextNext[0][15] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[0][14] = true;
+            next[1][15] = true;
+        } else {
+            if (nearbyChunkSections[2] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[2].getType(15, y, 15))] || nearbyChunkSections[1] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[1].getType(0, y, 0))] || current[0][15]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[0][15] = true;
+        }
+
+        //All inner lines
+        for (int z = 1; z < 15; z++) {
+            //First block
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[z][0] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[z][1] = true;
+                next[z - 1][0] = true;
+                next[z + 1][0] = true;
+            } else {
+                if (nearbyChunkSections[0] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[0].getType(15, y, z))] || current[z][0]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[z][0] = true;
+            }
+
+            //All inner blocks
+            for (int x = 1; x < 15; x++) {
+                dataBits = dataBitsReader.read();
+
+                if (nextNext[z][x] = !solid[dataBits]) {
+                    dataBitsWriter.skip();
+                    next[z][x - 1] = true;
+                    next[z][x + 1] = true;
+                    next[z - 1][x] = true;
+                    next[z + 1][x] = true;
+                } else {
+                    if (current[z][x]) {
+                        dataBitsWriter.skip();
+                    } else {
+                        if (counter >= predefinedBlockDataBits.length) {
+                            counter = 0;
+                        }
+
+                        dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                    }
+                }
+
+                if (!obfuscate[dataBits]) {
+                    next[z][x] = true;
+                }
+            }
+
+            //Last block
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[z][15] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[z][14] = true;
+                next[z - 1][15] = true;
+                next[z + 1][15] = true;
+            } else {
+                if (nearbyChunkSections[1] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[1].getType(0, y, z))] || current[z][15]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[z][15] = true;
+            }
+        }
+
+        //First block of last line
+        dataBits = dataBitsReader.read();
+
+        if (nextNext[15][0] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[15][1] = true;
+            next[14][0] = true;
+        } else {
+            if (nearbyChunkSections[3] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[3].getType(0, y, 0))] || nearbyChunkSections[0] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[0].getType(15, y, 15))] || current[15][0]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[15][0] = true;
+        }
+
+        //Last line
+        for (int x = 1; x < 15; x++) {
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[15][x] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[15][x - 1] = true;
+                next[15][x + 1] = true;
+                next[14][x] = true;
+            } else {
+                if (nearbyChunkSections[3] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[3].getType(x, y, 0))] || current[15][x]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[15][x] = true;
+            }
+        }
+
+        //Last block of last line
+        dataBits = dataBitsReader.read();
+
+        if (nextNext[15][15] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[15][14] = true;
+            next[14][15] = true;
+        } else {
+            if (nearbyChunkSections[3] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[3].getType(15, y, 0))] || nearbyChunkSections[1] == Chunk.EMPTY_CHUNK_SECTION || !solidGlobal[Block.REGISTRY_ID.getId(nearbyChunkSections[1].getType(0, y, 15))] || current[15][15]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[15][15] = true;
+        }
+
+        return counter;
+    }
+
+    private boolean[] readDataPalette(DataPalette dataPalette, boolean[] temp, boolean[] global) {
+        if (dataPalette instanceof DataPaletteGlobal) {
+            return global;
+        }
+
+        IBlockData blockData;
+
+        for (int i = 0; (blockData = dataPalette.getBlockData(i)) != null; i++) {
+            temp[i] = global[Block.REGISTRY_ID.getId(blockData)];
+        }
+
+        return temp;
+    }
+
+    @Override
+    public void updateNearbyBlocks(World world, BlockPosition blockPosition) {
+        if (updateRadius >= 2) {
+            BlockPosition temp = blockPosition.west();
+            updateBlock(world, temp);
+            updateBlock(world, temp.west());
+            updateBlock(world, temp.down());
+            updateBlock(world, temp.up());
+            updateBlock(world, temp.north());
+            updateBlock(world, temp.south());
+            updateBlock(world, temp = blockPosition.east());
+            updateBlock(world, temp.east());
+            updateBlock(world, temp.down());
+            updateBlock(world, temp.up());
+            updateBlock(world, temp.north());
+            updateBlock(world, temp.south());
+            updateBlock(world, temp = blockPosition.down());
+            updateBlock(world, temp.down());
+            updateBlock(world, temp.north());
+            updateBlock(world, temp.south());
+            updateBlock(world, temp = blockPosition.up());
+            updateBlock(world, temp.up());
+            updateBlock(world, temp.north());
+            updateBlock(world, temp.south());
+            updateBlock(world, temp = blockPosition.north());
+            updateBlock(world, temp.north());
+            updateBlock(world, temp = blockPosition.south());
+            updateBlock(world, temp.south());
+        } else if (updateRadius == 1) {
+            updateBlock(world, blockPosition.west());
+            updateBlock(world, blockPosition.east());
+            updateBlock(world, blockPosition.down());
+            updateBlock(world, blockPosition.up());
+            updateBlock(world, blockPosition.north());
+            updateBlock(world, blockPosition.south());
+        } else {
+            //Do nothing if updateRadius <= 0 (test mode)
+        }
+    }
+
+    private void updateBlock(World world, BlockPosition blockPosition) {
+        if (world.isLoaded(blockPosition)) {
+            IBlockData blockData = world.getType(blockPosition);
+
+            if (obfuscateGlobal[Block.REGISTRY_ID.getId(blockData)]) {
+                world.notify(blockPosition, blockData, blockData, 3);
+            }
+        }
+    }
+
+    public enum EngineMode {
+
+        HIDE(1, "hide ores"),
+        OBFUSCATE(2, "obfuscate");
+
+        private final int id;
+        private final String description;
+
+        EngineMode(int id, String description) {
+            this.id = id;
+            this.description = description;
+        }
+
+        public static EngineMode getById(int id) {
+            for (EngineMode engineMode : values()) {
+                if (engineMode.id == id) {
+                    return engineMode;
+                }
+            }
+
+            return null;
+        }
+
+        public int getId() {
+            return id;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+    }
+
+    public enum ChunkEdgeMode {
+
+        DEFAULT(1, "default"),
+        WAIT(2, "wait until nearby chunks are loaded"),
+        LOAD(3, "load nearby chunks");
+
+        private final int id;
+        private final String description;
+
+        ChunkEdgeMode(int id, String description) {
+            this.id = id;
+            this.description = description;
+        }
+
+        public static ChunkEdgeMode getById(int id) {
+            for (ChunkEdgeMode chunkEdgeMode : values()) {
+                if (chunkEdgeMode.id == id) {
+                    return chunkEdgeMode;
+                }
+            }
+
+            return null;
+        }
+
+        public int getId() {
+            return id;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/DataBitsReader.java b/src/main/java/com/destroystokyo/paper/antixray/DataBitsReader.java
new file mode 100644
index 000000000..92399318c
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/DataBitsReader.java
@@ -0,0 +1,56 @@
+package com.destroystokyo.paper.antixray;
+
+public class DataBitsReader {
+
+    private byte[] dataBits;
+    private int bitsPerValue;
+    private int mask;
+    private int longInDataBitsIndex;
+    private int bitInLongIndex;
+    private long current;
+
+    public void setDataBits(byte[] dataBits) {
+        this.dataBits = dataBits;
+    }
+
+    public void setBitsPerValue(int bitsPerValue) {
+        this.bitsPerValue = bitsPerValue;
+        mask = (1 << bitsPerValue) - 1;
+    }
+
+    public void setIndex(int index) {
+        this.longInDataBitsIndex = index;
+        bitInLongIndex = 0;
+        init();
+    }
+
+    private void init() {
+        if (dataBits.length > longInDataBitsIndex + 7) {
+            current = ((((long) dataBits[longInDataBitsIndex]) << 56)
+                    | (((long) dataBits[longInDataBitsIndex + 1] & 0xff) << 48)
+                    | (((long) dataBits[longInDataBitsIndex + 2] & 0xff) << 40)
+                    | (((long) dataBits[longInDataBitsIndex + 3] & 0xff) << 32)
+                    | (((long) dataBits[longInDataBitsIndex + 4] & 0xff) << 24)
+                    | (((long) dataBits[longInDataBitsIndex + 5] & 0xff) << 16)
+                    | (((long) dataBits[longInDataBitsIndex + 6] & 0xff) << 8)
+                    | (((long) dataBits[longInDataBitsIndex + 7] & 0xff)));
+        }
+    }
+
+    public int read() {
+        int value = (int) (current >>> bitInLongIndex) & mask;
+        bitInLongIndex += bitsPerValue;
+
+        if (bitInLongIndex > 63) {
+            bitInLongIndex -= 64;
+            longInDataBitsIndex += 8;
+            init();
+
+            if (bitInLongIndex > 0) {
+                value |= current << bitsPerValue - bitInLongIndex & mask;
+            }
+        }
+
+        return value;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/DataBitsWriter.java b/src/main/java/com/destroystokyo/paper/antixray/DataBitsWriter.java
new file mode 100644
index 000000000..aca0b9d71
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/DataBitsWriter.java
@@ -0,0 +1,84 @@
+package com.destroystokyo.paper.antixray;
+
+public class DataBitsWriter {
+
+    private byte[] dataBits;
+    private int bitsPerValue;
+    private long mask;
+    private int longInDataBitsIndex;
+    private int bitInLongIndex;
+    private long current;
+    private boolean dirty;
+
+    public void setDataBits(byte[] dataBits) {
+        this.dataBits = dataBits;
+    }
+
+    public void setBitsPerValue(int bitsPerValue) {
+        this.bitsPerValue = bitsPerValue;
+        mask = (1 << bitsPerValue) - 1;
+    }
+
+    public void setIndex(int index) {
+        this.longInDataBitsIndex = index;
+        bitInLongIndex = 0;
+        init();
+    }
+
+    private void init() {
+        if (dataBits.length > longInDataBitsIndex + 7) {
+            current = ((((long) dataBits[longInDataBitsIndex]) << 56)
+                    | (((long) dataBits[longInDataBitsIndex + 1] & 0xff) << 48)
+                    | (((long) dataBits[longInDataBitsIndex + 2] & 0xff) << 40)
+                    | (((long) dataBits[longInDataBitsIndex + 3] & 0xff) << 32)
+                    | (((long) dataBits[longInDataBitsIndex + 4] & 0xff) << 24)
+                    | (((long) dataBits[longInDataBitsIndex + 5] & 0xff) << 16)
+                    | (((long) dataBits[longInDataBitsIndex + 6] & 0xff) << 8)
+                    | (((long) dataBits[longInDataBitsIndex + 7] & 0xff)));
+        }
+
+        dirty = false;
+    }
+
+    public void finish() {
+        if (dirty && dataBits.length > longInDataBitsIndex + 7) {
+            dataBits[longInDataBitsIndex] = (byte) (current >> 56 & 0xff);
+            dataBits[longInDataBitsIndex + 1] = (byte) (current >> 48 & 0xff);
+            dataBits[longInDataBitsIndex + 2] = (byte) (current >> 40 & 0xff);
+            dataBits[longInDataBitsIndex + 3] = (byte) (current >> 32 & 0xff);
+            dataBits[longInDataBitsIndex + 4] = (byte) (current >> 24 & 0xff);
+            dataBits[longInDataBitsIndex + 5] = (byte) (current >> 16 & 0xff);
+            dataBits[longInDataBitsIndex + 6] = (byte) (current >> 8 & 0xff);
+            dataBits[longInDataBitsIndex + 7] = (byte) (current & 0xff);
+        }
+    }
+
+    public void write(int value) {
+        current = current & ~(mask << bitInLongIndex) | (value & mask) << bitInLongIndex;
+        dirty = true;
+        bitInLongIndex += bitsPerValue;
+
+        if (bitInLongIndex > 63) {
+            finish();
+            bitInLongIndex -= 64;
+            longInDataBitsIndex += 8;
+            init();
+
+            if (bitInLongIndex > 0) {
+                current = current & ~(mask >>> bitsPerValue - bitInLongIndex) | (value & mask) >>> bitsPerValue - bitInLongIndex;
+                dirty = true;
+            }
+        }
+    }
+
+    public void skip() {
+        bitInLongIndex += bitsPerValue;
+
+        if (bitInLongIndex > 63) {
+            finish();
+            bitInLongIndex -= 64;
+            longInDataBitsIndex += 8;
+            init();
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/PacketPlayOutMapChunkInfo.java b/src/main/java/com/destroystokyo/paper/antixray/PacketPlayOutMapChunkInfo.java
new file mode 100644
index 000000000..0bd269a07
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/PacketPlayOutMapChunkInfo.java
@@ -0,0 +1,80 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.DataPalette;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMapChunk;
+
+public class PacketPlayOutMapChunkInfo {
+
+    private final PacketPlayOutMapChunk packetPlayOutMapChunk;
+    private final Chunk chunk;
+    private final int chunkSectionSelector;
+    private byte[] data;
+    private final int[] bitsPerValue = new int[16];
+    private final DataPalette[] dataPalettes = new DataPalette[16];
+    private final int[] dataBitsIndexes = new int[16];
+    private final IBlockData[][] predefinedBlockData = new IBlockData[16][];
+
+    public PacketPlayOutMapChunkInfo(PacketPlayOutMapChunk packetPlayOutMapChunk, Chunk chunk, int chunkSectionSelector) {
+        this.packetPlayOutMapChunk = packetPlayOutMapChunk;
+        this.chunk = chunk;
+        this.chunkSectionSelector = chunkSectionSelector;
+    }
+
+    public PacketPlayOutMapChunk getPacketPlayOutMapChunk() {
+        return packetPlayOutMapChunk;
+    }
+
+    public Chunk getChunk() {
+        return chunk;
+    }
+
+    public int getChunkSectionSelector() {
+        return chunkSectionSelector;
+    }
+
+    public byte[] getData() {
+        return data;
+    }
+
+    public void setData(byte[] data) {
+        this.data = data;
+    }
+
+    public int getBitsPerValue(int chunkSectionIndex) {
+        return bitsPerValue[chunkSectionIndex];
+    }
+
+    public void setBitsPerValue(int chunkSectionIndex, int bitsPerValue) {
+        this.bitsPerValue[chunkSectionIndex] = bitsPerValue;
+    }
+
+    public DataPalette getDataPalette(int chunkSectionIndex) {
+        return dataPalettes[chunkSectionIndex];
+    }
+
+    public void setDataPalette(int chunkSectionIndex, DataPalette dataPalette) {
+        dataPalettes[chunkSectionIndex] = dataPalette;
+    }
+
+    public int getDataBitsIndex(int chunkSectionIndex) {
+        return dataBitsIndexes[chunkSectionIndex];
+    }
+
+    public void setDataBitsIndex(int chunkSectionIndex, int dataBitsIndex) {
+        dataBitsIndexes[chunkSectionIndex] = dataBitsIndex;
+    }
+
+    public IBlockData[] getPredefinedBlockData(int chunkSectionIndex) {
+        return predefinedBlockData[chunkSectionIndex];
+    }
+
+    public void setPredefinedBlockData(int chunkSectionIndex, IBlockData[] predefinedBlockData) {
+        this.predefinedBlockData[chunkSectionIndex] = predefinedBlockData;
+    }
+
+    public boolean isWritten(int chunkSectionIndex) {
+        return bitsPerValue[chunkSectionIndex] != 0;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/PacketPlayOutMapChunkInfoAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/PacketPlayOutMapChunkInfoAntiXray.java
new file mode 100644
index 000000000..8ea2beb59
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/PacketPlayOutMapChunkInfoAntiXray.java
@@ -0,0 +1,28 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.server.Chunk;
+import net.minecraft.server.PacketPlayOutMapChunk;
+
+public class PacketPlayOutMapChunkInfoAntiXray extends PacketPlayOutMapChunkInfo implements Runnable {
+
+    private Chunk[] nearbyChunks;
+    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+
+    public PacketPlayOutMapChunkInfoAntiXray(PacketPlayOutMapChunk packetPlayOutMapChunk, Chunk chunk, int chunkSectionSelector, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+        super(packetPlayOutMapChunk, chunk, chunkSectionSelector);
+        this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
+    }
+
+    public Chunk[] getNearbyChunks() {
+        return nearbyChunks;
+    }
+
+    public void setNearbyChunks(Chunk... nearbyChunks) {
+        this.nearbyChunks = nearbyChunks;
+    }
+
+    @Override
+    public void run() {
+        chunkPacketBlockControllerAntiXray.obfuscate(this);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index fedc38dc1..a96a2a28d 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -862,7 +862,7 @@ public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
         for (int i = 0; i < nbttaglist.size(); ++i) {
             NBTTagCompound nbttagcompound = nbttaglist.getCompound(i);
             byte b0 = nbttagcompound.getByte("Y");
-            ChunkSection chunksection = new ChunkSection(b0 << 4, flag1);
+            ChunkSection chunksection = new ChunkSection(b0 << 4, flag1, world.chunkPacketBlockController.getPredefinedBlockData(chunk, b0)); // Paper - Anti-Xray - Add predefined block data
 
             chunksection.getBlocks().a(nbttagcompound, "Palette", "BlockStates");
             chunksection.a(new NibbleArray(nbttagcompound.getByteArray("BlockLight")));
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
index 0fb3162e6..54df71404 100644
--- a/src/main/java/net/minecraft/server/DataBits.java
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -60,6 +60,7 @@ public class DataBits {
         }
     }
 
+    public long[] getDataBits() { return this.a(); } // Paper - Anti-Xray - OBFHELPER
     public long[] a() {
         return this.a;
     }
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index c4a25bd87..b92432d50 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -75,6 +75,7 @@ public class EntityFallingBlock extends Entity {
                 blockposition = new BlockPosition(this);
                 if (this.world.getType(blockposition).getBlock() == block && !CraftEventFactory.callEntityChangeBlockEvent(this, blockposition, Blocks.AIR.getBlockData()).isCancelled()) {
                     this.world.setAir(blockposition);
+                    this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
                 } else if (!this.world.isClientSide) {
                     this.die();
                     return;
@@ -140,6 +141,7 @@ public class EntityFallingBlock extends Entity {
                                     return;
                                 }
                                 this.world.setTypeAndData(blockposition, this.block, 3);
+                                this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
                                 // CraftBukkit end
                                 if (block instanceof BlockFalling) {
                                     ((BlockFalling) block).a(this.world, blockposition, this.block, iblockdata);
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index 2652b1575..09f90450a 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -234,6 +234,7 @@ public class Explosion {
                 blockposition = (BlockPosition) iterator.next();
                 IBlockData iblockdata = this.world.getType(blockposition);
                 Block block = iblockdata.getBlock();
+                this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
 
                 if (flag) {
                     double d0 = (double) ((float) blockposition.getX() + this.world.random.nextFloat());
diff --git a/src/main/java/net/minecraft/server/PacketDataSerializer.java b/src/main/java/net/minecraft/server/PacketDataSerializer.java
index d04afceb7..02ab42a64 100644
--- a/src/main/java/net/minecraft/server/PacketDataSerializer.java
+++ b/src/main/java/net/minecraft/server/PacketDataSerializer.java
@@ -33,6 +33,7 @@ public class PacketDataSerializer extends ByteBuf {
         this.a = bytebuf;
     }
 
+    public static int countBytes(int i) { return PacketDataSerializer.a(i); } // Paper - Anti-Xray - OBFHELPER
     public static int a(int i) {
         for (int j = 1; j < 5; ++j) {
             if ((i & -1 << j * 7) == 0) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 344b95233..32b790397 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -108,6 +108,8 @@ public class PlayerChunk {
             return false;
         } else if (!this.chunk.isReady()) {
             return false;
+        } else if (!this.chunk.world.chunkPacketBlockController.onChunkPacketCreate(this.chunk, '\uffff', false)) { // Paper - Anti-Xray - Load nearby chunks if necessary
+            return false; // Paper - Anti-Xray - Wait and try again later
         } else {
             this.dirtyCount = 0;
             this.h = 0;
@@ -128,6 +130,7 @@ public class PlayerChunk {
 
     public void sendChunk(EntityPlayer entityplayer) {
         if (this.done) {
+            this.chunk.world.chunkPacketBlockController.onChunkPacketCreate(this.chunk, '\uffff', true); // Paper - Anti-Xray - Load nearby chunks if necessary
             entityplayer.playerConnection.sendPacket(new PacketPlayOutMapChunk(this.chunk, '\uffff'));
             this.playerChunkMap.getWorld().getTracker().a(entityplayer, this.chunk);
         }
@@ -192,6 +195,8 @@ public class PlayerChunk {
                         this.a(this.playerChunkMap.getWorld().getTileEntity(blockposition));
                     }
                 } else if (this.dirtyCount == 64) {
+                    // Paper - Anti-Xray - Loading chunks here could cause a ConcurrentModificationException #1104
+                    //this.chunk.world.chunkPacketBlockController.onChunkPacketCreate(this.chunk, this.h, true); // Paper - Anti-Xray - Load nearby chunks if necessary
                     this.a((Packet) (new PacketPlayOutMapChunk(this.chunk, this.h)));
                 } else {
                     this.a((Packet) (new PacketPlayOutMultiBlockChange(this.dirtyCount, this.dirtyBlocks, this.chunk)));
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index e34198e40..ce8f76871 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -201,6 +201,8 @@ public class PlayerInteractManager {
             }
 
         }
+
+        this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
     }
 
     public void a(BlockPosition blockposition) {
diff --git a/src/main/java/net/minecraft/server/RegistryBlockID.java b/src/main/java/net/minecraft/server/RegistryBlockID.java
index ef332d651..35c3edca4 100644
--- a/src/main/java/net/minecraft/server/RegistryBlockID.java
+++ b/src/main/java/net/minecraft/server/RegistryBlockID.java
@@ -56,6 +56,7 @@ public class RegistryBlockID<T> implements Registry<T> {
         return Iterators.filter(this.c.iterator(), Predicates.notNull());
     }
 
+    public int size() { return this.a(); } // Paper - Anti-Xray - OBFHELPER
     public int a() {
         return this.b.size();
     }
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 49e7c1589..62fd2e503 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -39,6 +39,8 @@ import org.bukkit.generator.ChunkGenerator;
 // CraftBukkit end
 // Paper start
 import java.util.Set;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController; // Anti-Xray
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray; // Anti-Xray
 import com.google.common.collect.Sets;
 // Paper end
 public abstract class World implements GeneratorAccess, IIBlockAccess, AutoCloseable {
@@ -136,6 +138,7 @@ public abstract class World implements GeneratorAccess, IIBlockAccess, AutoClose
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
     public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
+    public final ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
 
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
     private boolean guardEntityList; // Spigot
@@ -161,6 +164,7 @@ public abstract class World implements GeneratorAccess, IIBlockAccess, AutoClose
     protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig( worlddata.getName() ); // Spigot
         this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(worlddata.getName(), this.spigotConfig); // Paper
+        this.chunkPacketBlockController = this.paperConfig.antiXray ? new ChunkPacketBlockControllerAntiXray(this.paperConfig) : ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
         this.generator = gen;
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
@@ -500,6 +504,7 @@ public abstract class World implements GeneratorAccess, IIBlockAccess, AutoClose
             ((IWorldAccess) this.v.get(j)).a(this, blockposition, iblockdata, iblockdata1, i);
         }
 
+        this.chunkPacketBlockController.updateNearbyBlocks(this, blockposition); // Paper - Anti-Xray
     }
 
     public void update(BlockPosition blockposition, Block block) {
-- 
2.18.0

