From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Noah van der Aa <ndvdaa@gmail.com>
Date: Tue, 3 Aug 2021 17:28:27 +0200
Subject: [PATCH] Hide unnecessary itemmeta from clients

TODO: Needs updating for data components

diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 22eec853588ded2d255ab69d408f8e987832abe2..dda4fbd63681ab9614ebbb55632355f30d7b19ac 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -348,7 +348,10 @@ public class ServerEntity {
                 ItemStack itemstack = ((LivingEntity) this.entity).getItemBySlot(enumitemslot);
 
                 if (!itemstack.isEmpty()) {
-                    list.add(Pair.of(enumitemslot, itemstack.copy()));
+                    // Paper start - prevent oversized data
+                    final ItemStack sanitized = LivingEntity.sanitizeItemStack(itemstack.copy(), false);
+                    list.add(Pair.of(enumitemslot, ((LivingEntity) this.entity).stripMeta(sanitized, false))); // Paper - Hide unnecessary item meta
+                    // Paper end - prevent oversized data
                 }
             }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 32076a765d48d59b339d600f69afa85edbcf833c..6b905d0245f16794078de34fb8509a0cd0869382 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2802,8 +2802,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 // Refresh the current entity metadata
                                 entity.refreshEntityData(ServerGamePacketListenerImpl.this.player);
                                 // SPIGOT-7136 - Allays
-                                if (entity instanceof Allay) {
-                                    ServerGamePacketListenerImpl.this.send(new ClientboundSetEquipmentPacket(entity.getId(), Arrays.stream(net.minecraft.world.entity.EquipmentSlot.values()).map((slot) -> Pair.of(slot, ((LivingEntity) entity).getItemBySlot(slot).copy())).collect(Collectors.toList())));
+                                if (entity instanceof Allay allay) { // Paper - Hide unnecessary item meta
+                                    ServerGamePacketListenerImpl.this.send(new ClientboundSetEquipmentPacket(entity.getId(), Arrays.stream(net.minecraft.world.entity.EquipmentSlot.values()).map((slot) -> Pair.of(slot, allay.stripMeta(allay.getItemBySlot(slot), true))).collect(Collectors.toList()))); // Paper - Hide unnecessary item meta
                                     ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote();
                                 }
                             }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 9ff43ff4076c658b8561c5a7abd067423830f964..bbc67e97de3ab1cd20c595e794aea27cf00a7cb0 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3299,7 +3299,10 @@ public abstract class LivingEntity extends Entity implements Attackable {
         equipmentChanges.forEach((enumitemslot, itemstack) -> {
             ItemStack itemstack1 = itemstack.copy();
 
-            list.add(Pair.of(enumitemslot, itemstack1));
+            // Paper start - prevent oversized data
+            ItemStack toSend = sanitizeItemStack(itemstack1, true);
+            list.add(Pair.of(enumitemslot, stripMeta(toSend, toSend == itemstack1))); // Paper - Hide unnecessary item meta
+            // Paper end - prevent oversized data
             switch (enumitemslot.getType()) {
                 case HAND:
                     this.setLastHandItem(enumitemslot, itemstack1);
@@ -3315,6 +3318,105 @@ public abstract class LivingEntity extends Entity implements Attackable {
         ((ServerLevel) this.level()).getChunkSource().broadcast(this, new ClientboundSetEquipmentPacket(this.getId(), list));
     }
 
+    // Paper start - Hide unnecessary item meta
+    public ItemStack stripMeta(final ItemStack itemStack, final boolean copyItemStack) {
+        if (itemStack.isEmpty() || (!itemStack.hasTag() && itemStack.getCount() < 2)) {
+            return itemStack;
+        }
+
+        final ItemStack copy = copyItemStack ? itemStack.copy() : itemStack;
+        if (this.level().paperConfig().anticheat.obfuscation.items.hideDurability) {
+            // Only show damage values for elytra's, since they show a different texture when broken.
+            if (!copy.is(Items.ELYTRA) || copy.getDamageValue() < copy.getMaxDamage() - 1) {
+                copy.setDamageValue(0);
+            }
+        }
+
+        final CompoundTag tag = copy.getTag();
+        if (this.level().paperConfig().anticheat.obfuscation.items.hideItemmeta) {
+            // Some resource packs show different textures when there is more than one item. Since this shouldn't provide a big advantage,
+            // we'll tell the client if there's one or (more than) two items.
+            copy.setCount(copy.getCount() > 1 ? 2 : 1);
+            // We can't just strip out display, leather helmets still use the display.color tag.
+            if (tag != null) {
+                if (tag.get("display") instanceof CompoundTag displayTag) {
+                    displayTag.remove("Lore");
+                    displayTag.remove("Name");
+                }
+
+                if (tag.get("Enchantments") instanceof ListTag enchantmentsTag && !enchantmentsTag.isEmpty()) {
+                    // The client still renders items with the enchantment glow if the enchantments tag contains at least one (empty) child.
+                    ListTag enchantments = new ListTag();
+                    CompoundTag fakeEnchantment = new CompoundTag();
+                    // Soul speed boots generate client side particles.
+                    if (EnchantmentHelper.getItemEnchantmentLevel(Enchantments.SOUL_SPEED, itemStack) > 0) {
+                        fakeEnchantment.putString("id", org.bukkit.enchantments.Enchantment.SOUL_SPEED.getKey().asString());
+                        fakeEnchantment.putInt("lvl", 1);
+                    }
+                    enchantments.add(fakeEnchantment);
+                    tag.put("Enchantments", enchantments);
+                }
+                tag.remove("AttributeModifiers");
+                tag.remove("Unbreakable");
+                tag.remove("PublicBukkitValues"); // Persistent data container1
+
+                // Books
+                tag.remove("author");
+                tag.remove("filtered_title");
+                tag.remove("pages");
+                tag.remove("filtered_pages");
+                tag.remove("title");
+                tag.remove("generation");
+
+                // Filled maps
+                tag.remove("map");
+                tag.remove("map_scale_direction");
+                tag.remove("map_to_lock");
+            }
+        }
+
+        if (this.level().paperConfig().anticheat.obfuscation.items.hideItemmetaWithVisualEffects && tag != null) {
+            // Lodestone compasses
+            tag.remove("LodestonePos");
+            if (tag.contains("LodestoneDimension")) {
+                // The client shows the glint if either the position or the dimension is present, so we just wipe
+                // the position and fake the dimension
+                tag.putString("LodestoneDimension", "paper:paper");
+            }
+        }
+
+        return copy;
+    }
+    // Paper end - Hide unnecessary item meta
+
+    // Paper start - prevent oversized data
+    public static ItemStack sanitizeItemStack(final ItemStack itemStack, final boolean copyItemStack) {
+        if (itemStack.isEmpty() || !itemStack.hasTag()) {
+            return itemStack;
+        }
+
+        final ItemStack copy = copyItemStack ? itemStack.copy() : itemStack;
+        final CompoundTag tag = copy.getTag();
+        if (copy.is(Items.BUNDLE) && tag.get("Items") instanceof ListTag oldItems && !oldItems.isEmpty()) {
+            // Bundles change their texture based on their fullness.
+            org.bukkit.inventory.meta.BundleMeta bundleMeta = (org.bukkit.inventory.meta.BundleMeta) copy.asBukkitMirror().getItemMeta();
+            int sizeUsed = 0;
+            for (org.bukkit.inventory.ItemStack item : bundleMeta.getItems()) {
+                int scale = 64 / item.getMaxStackSize();
+                sizeUsed += scale * item.getAmount();
+            }
+            // Now we add a single fake item that uses the same amount of slots as all other items.
+            ListTag items = new ListTag();
+            items.add(new ItemStack(Items.PAPER, sizeUsed).save(new CompoundTag()));
+            tag.put("Items", items);
+        }
+        if (tag.get("BlockEntityTag") instanceof CompoundTag blockEntityTag) {
+            blockEntityTag.remove("Items");
+        }
+        return copy;
+    }
+    // Paper end - prevent oversized data
+
     private ItemStack getLastArmorItem(EquipmentSlot slot) {
         return (ItemStack) this.lastArmorItemStacks.get(slot.getIndex());
     }
