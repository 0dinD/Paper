From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Wed, 7 Dec 2022 17:25:19 -0500
Subject: [PATCH] Properly resend entities

This resolves some issues which caused entities to not be resent correctly.
Entities that are interacted with need to be resent to the client, so we resend all the entity
data to the player whilst making sure not to clear dirty entries from the tracker. This makes
sure that values will be correctly updated to other players.

This also adds utilities to aid in further preventing entity desyncs.

This also also fixes the bug causing cancelling PlayerInteractEvent to cause items to continue
to be used despite being cancelled on the server.

For example, items being consumed but never finishing, shields being put up, etc.
The underlying issue of this is that the client modifies their synced data values,
and so we have to (forcibly) resend them in order for the client to reset their using item state.

See: https://github.com/PaperMC/Paper/pull/1896

== AT ==
public net.minecraft.server.level.ChunkMap$TrackedEntity serverEntity

diff --git a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
index 02bf2705ca1c99023a83a22d92e1962181102297..0f99733660f91280e4c6262cf75b3c9cae86f65a 100644
--- a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
+++ b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
@@ -50,7 +50,7 @@ public class SynchedEntityData {
         }
     }
 
-    private <T> SynchedEntityData.DataItem<T> getItem(EntityDataAccessor<T> key) {
+    public <T> SynchedEntityData.DataItem<T> getItem(EntityDataAccessor<T> key) { // Paper - public
         return (SynchedEntityData.DataItem<T>) this.itemsById[key.id()]; // CraftBukkit - decompile error
     }
 
@@ -151,6 +151,20 @@ public class SynchedEntityData {
         }
     }
 
+    // Paper start
+    // We need to pack all as we cannot rely on "non default values" or "dirty" ones.
+    // Because these values can possibly be desynced on the client.
+    @Nullable
+    public List<SynchedEntityData.DataValue<?>> packAll() {
+        final List<SynchedEntityData.DataValue<?>> list = new ArrayList<>();
+        for (final DataItem<?> dataItem : this.itemsById) {
+            list.add(dataItem.value());
+        }
+
+        return list;
+    }
+    // Paper end
+
     public static class DataItem<T> {
 
         final EntityDataAccessor<T> accessor;
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index abb9a86cd42a34cf722a312068134e820ac21956..3b6ebe8f9575783a1607eb6667554ca66de94271 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -556,6 +556,7 @@ public class ServerPlayerGameMode {
             }
             // Paper end - extend Player Interact cancellation
             player.getBukkitEntity().updateInventory(); // SPIGOT-2867
+            this.player.resyncUsingItem(this.player); // Paper - Properly cancel usable items
             return (event.useItemInHand() != Event.Result.ALLOW) ? InteractionResult.SUCCESS : InteractionResult.PASS;
         } else if (this.gameModeForPlayer == GameType.SPECTATOR) {
             MenuProvider itileinventory = iblockdata.getMenuProvider(world, blockposition);
@@ -609,6 +610,11 @@ public class ServerPlayerGameMode {
             } else {
                 return InteractionResult.PASS;
             }
+            // Paper start - Properly cancel usable items; Cancel only if cancelled + if the interact result is different from default response
+            else if (this.interactResult && this.interactResult != cancelledItem) {
+                this.player.resyncUsingItem(this.player);
+            }
+            // Paper end - Properly cancel usable items
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 88fc56fa521c36accd807ca1704136f29733e52f..a771f78f63e4f26c0ba411a3c355f8dfbb5f4a61 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2010,6 +2010,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             }
 
             if (cancelled) {
+                this.player.resyncUsingItem(this.player); // Paper - Properly cancel usable items
                 this.player.getBukkitEntity().updateInventory(); // SPIGOT-2524
                 return;
             }
@@ -2794,7 +2795,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                             // Entity in bucket - SPIGOT-4048 and SPIGOT-6859a
                             if ((entity instanceof Bucketable && entity instanceof LivingEntity && origItem != null && origItem.asItem() == Items.WATER_BUCKET) && (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelected() == null || ServerGamePacketListenerImpl.this.player.getInventory().getSelected().getItem() != origItem)) {
-                                ServerGamePacketListenerImpl.this.send(new ClientboundAddEntityPacket(entity));
+                                entity.getEntityData().resendPossiblyDesyncedEntityData(player); // Paper - The entire mob gets deleted, so resend it.
                                 ServerGamePacketListenerImpl.this.player.containerMenu.sendAllDataToRemote();
                             }
 
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index c83ec24c0bf54f8699caa2d37bfe82d273f7b16c..dd628c8190704505fde543a8853d5b4dbc8252d5 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -393,7 +393,7 @@ public abstract class PlayerList {
         ((ServerLevel)player.level()).getChunkSource().chunkMap.addEntity(player); // Paper - Fire PlayerJoinEvent when Player is actually ready; track entity now
         // CraftBukkit end
 
-        player.refreshEntityData(player); // CraftBukkit - BungeeCord#2321, send complete data to self on spawn
+        //player.refreshEntityData(player); // CraftBukkit - BungeeCord#2321, send complete data to self on spawn // Paper - THIS IS NOT NEEDED ANYMORE
 
         this.sendLevelInfo(player, worldserver1);
 
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 8ad2d17615ff489b2fbbb13480dd0b217a42d805..130ad5dc8ef5cfe1cfc0a166eba2cf67d424ff69 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.MCUtil;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
 import java.util.Arrays;
@@ -59,7 +60,6 @@ import net.minecraft.network.syncher.SyncedDataHolder;
 import net.minecraft.network.syncher.SynchedEntityData;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
@@ -129,28 +129,22 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
-import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
-import org.bukkit.Server;
 import org.bukkit.block.BlockFace;
 import org.bukkit.command.CommandSender;
-import org.bukkit.craftbukkit.event.CraftPortalEvent;
-import org.bukkit.entity.Hanging;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.entity.EntityCombustByEntityEvent;
-import org.bukkit.event.hanging.HangingBreakByEntityEvent;
-import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
-import org.bukkit.event.vehicle.VehicleEnterEvent;
-import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.event.CraftPortalEvent;
 import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Pose;
+import org.bukkit.entity.Vehicle;
 import org.bukkit.event.entity.EntityAirChangeEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityCombustEvent;
 import org.bukkit.event.entity.EntityDismountEvent;
 import org.bukkit.event.entity.EntityDropItemEvent;
@@ -158,8 +152,13 @@ import org.bukkit.event.entity.EntityMountEvent;
 import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.plugin.PluginManager;
+import org.slf4j.Logger;
 // CraftBukkit end
 
 public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, CommandSource, ScoreHolder {
@@ -704,13 +703,44 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     // CraftBukkit start
     public void refreshEntityData(ServerPlayer to) {
-        List<SynchedEntityData.DataValue<?>> list = this.getEntityData().getNonDefaultValues();
+        List<SynchedEntityData.DataValue<?>> list = this.entityData.packAll(); // Paper - Update EVERYTHING not just not default
 
-        if (list != null) {
+        if (list != null && to.getBukkitEntity().canSee(this.getBukkitEntity())) { // Paper
             to.connection.send(new ClientboundSetEntityDataPacket(this.getId(), list));
         }
     }
     // CraftBukkit end
+    // Paper start
+    // This method should only be used if the data of an entity could have become desynced
+    // due to interactions on the client.
+    public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
+        if (this.tracker == null) {
+            return;
+        }
+
+        if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
+            final net.minecraft.server.level.ServerEntity serverEntity = this.tracker.serverEntity;
+            final List<net.minecraft.network.protocol.Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> list = new java.util.ArrayList<>();
+            serverEntity.sendPairingData(player, list::add);
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundBundlePacket(list));
+        }
+    }
+
+    // This method allows you to specifically resend certain data accessor keys to the client
+    public void resendPossiblyDesyncedDataValues(List<EntityDataAccessor<?>> keys, ServerPlayer to) {
+        if (!to.getBukkitEntity().canSee(this.getBukkitEntity())) {
+            return;
+        }
+
+        final List<SynchedEntityData.DataValue<?>> values = new java.util.ArrayList<>(keys.size());
+        for (final EntityDataAccessor<?> key : keys) {
+            final SynchedEntityData.DataItem<?> synchedValue = this.entityData.getItem(key);
+            values.add(synchedValue.value());
+        }
+
+        to.connection.send(new ClientboundSetEntityDataPacket(this.id, values));
+    }
+    // Paper end
 
     public boolean equals(Object object) {
         return object instanceof Entity ? ((Entity) object).id == this.id : false;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 75e01c1e01e0782fc8af48777bbe4716d37aeafa..9ff43ff4076c658b8561c5a7abd067423830f964 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3828,6 +3828,11 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return ((Byte) this.entityData.get(LivingEntity.DATA_LIVING_ENTITY_FLAGS) & 2) > 0 ? InteractionHand.OFF_HAND : InteractionHand.MAIN_HAND;
     }
 
+    // Paper start - Properly cancel usable items
+    public void resyncUsingItem(ServerPlayer serverPlayer) {
+        this.getEntityData().resendPossiblyDesyncedDataValues(java.util.List.of(DATA_LIVING_ENTITY_FLAGS), serverPlayer);
+    }
+    // Paper end - Properly cancel usable items
     private void updatingUsingItem() {
         if (this.isUsingItem()) {
             if (ItemStack.isSameItem(this.getItemInHand(this.getUsedItemHand()), this.useItem)) {
diff --git a/src/main/java/net/minecraft/world/entity/animal/Bucketable.java b/src/main/java/net/minecraft/world/entity/animal/Bucketable.java
index cb4a6439e9774bbec07e69b13df8dddd395b9ece..cfe37b4f5e33795ee717d824d86e3a0919129cf5 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Bucketable.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Bucketable.java
@@ -109,8 +109,7 @@ public interface Bucketable {
             itemstack1 = CraftItemStack.asNMSCopy(playerBucketFishEvent.getEntityBucket());
             if (playerBucketFishEvent.isCancelled()) {
                 ((ServerPlayer) player).containerMenu.sendAllDataToRemote(); // We need to update inventory to resync client's bucket
-                ((ServerPlayer) player).connection.send(new ClientboundAddEntityPacket(entity)); // We need to play out these packets as the client assumes the fish is gone
-                entity.refreshEntityData((ServerPlayer) player); // Need to send data such as the display name to client
+                entity.resendPossiblyDesyncedEntityData((ServerPlayer) player); // Paper
                 return Optional.of(InteractionResult.FAIL);
             }
             entity.playSound(((Bucketable) entity).getPickupSound(), 1.0F, 1.0F);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 3ab04c4bdbe26ff7f6f54eb9cdd58376c592fa05..f949514cf68d0ae2db754576e46f5bfc14ffdff4 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1010,7 +1010,11 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
             return;
         }
 
-        entityTracker.broadcast(this.getHandle().getAddEntityPacket());
+        // Paper start, resend possibly desynced entity instead of add entity packet
+        for (ServerPlayerConnection playerConnection : entityTracker.seenBy) {
+            this.getHandle().getEntityData().resendPossiblyDesyncedEntityData(playerConnection.getPlayer());
+        }
+        // Paper end
     }
 
     private static PermissibleBase getPermissibleBase() {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java
index 0801bcdee8fcff0d388d302387e4f1d587e0a283..2fcd9b836d42e3549a3b6b921c57a4c103146dff 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftItemFrame.java
@@ -39,9 +39,11 @@ public class CraftItemFrame extends CraftHanging implements ItemFrame {
     protected void update() {
         super.update();
 
+        // Paper start, don't mark as dirty as this is handled in super.update()
         // mark dirty, so that the client gets updated with item and rotation
-        this.getHandle().getEntityData().markDirty(net.minecraft.world.entity.decoration.ItemFrame.DATA_ITEM);
-        this.getHandle().getEntityData().markDirty(net.minecraft.world.entity.decoration.ItemFrame.DATA_ROTATION);
+        //this.getHandle().getEntityData().markDirty(net.minecraft.world.entity.decoration.ItemFrame.DATA_ITEM);
+        //this.getHandle().getEntityData().markDirty(net.minecraft.world.entity.decoration.ItemFrame.DATA_ROTATION);
+        // Paper end
 
         // update redstone
         if (!this.getHandle().generation) {
